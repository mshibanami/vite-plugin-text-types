import fs from 'node:fs';
import path from 'node:path';
import fg from 'fast-glob';

export interface FileInfo {
  absPath: string;
  viteKey: string;
  outKey: string;
}

export function collectFiles(
  root: string,
  include: string | string[],
  exclude: string | string[] | undefined,
  stripPrefix?: string,
): FileInfo[] {
  const patterns = (Array.isArray(include) ? include : [include]).map((p) => {
    return p.startsWith('/') ? p.slice(1) : p;
  });
  const ignore = (exclude ? (Array.isArray(exclude) ? exclude : [exclude]) : []).map((p) => {
    return p.startsWith('/') ? p.slice(1) : p;
  });
  const files = fg.sync(patterns, {
    cwd: root,
    absolute: true,
    ignore,
  });
  return files
    .map((abs) => {
      const normalizedAbs = abs.split(path.sep).join('/');
      const normalizedRoot = root.split(path.sep).join('/');
      let viteKey = path.posix.relative(normalizedRoot, normalizedAbs);
      if (!viteKey.startsWith('/')) {
        viteKey = '/' + viteKey;
      }
      let outKey = viteKey;
      if (stripPrefix) {
        if (outKey.startsWith(stripPrefix)) {
          outKey = outKey.slice(stripPrefix.length);
        } else if (stripPrefix.startsWith('/') && outKey.startsWith(stripPrefix)) {
          // This case is already covered by the first check if they match exactly
        } else if (!stripPrefix.startsWith('/') && outKey.startsWith('/' + stripPrefix)) {
          outKey = outKey.slice(stripPrefix.length + 1);
        }
      }
      return {
        absPath: abs,
        viteKey,
        outKey,
      };
    })
    .sort((a, b) => a.outKey.localeCompare(b.outKey));
}

export function normalizeLineEndings(content: string): string {
  return content.replace(/\r\n/g, '\n');
}

export function generateDts(
  virtualModuleId: string,
  entries: { key: string; content: string }[],
  maxLiteralLength = 50_000,
  delimiters: [string, string] = ['{{', '}}'],
): string {
  const lines: string[] = [];

  lines.push(`// AUTO-GENERATED by vite-plugin-text-types. DO NOT EDIT.`);
  lines.push(`declare module '${virtualModuleId}' {`);
  lines.push(`  export const texts: {`);

  for (const { key, content } of entries) {
    if (content.length > maxLiteralLength) {
      lines.push(`    ${JSON.stringify(key)}: string`);
    } else {
      lines.push(`    ${JSON.stringify(key)}: ${JSON.stringify(content)}`);
    }
  }

  lines.push(`  }`);
  lines.push(``);
  lines.push(
    `  type Trim<T extends string> = T extends \` \${infer R}\` ? Trim<R> : T extends \`\${infer L} \` ? Trim<L> : T;`,
  );
  lines.push(
    `  type ExtractVars<T extends string> = T extends \`\${string}${delimiters[0]}\${infer Prop}${delimiters[1]}\${infer Rest}\``,
  );
  lines.push(`    ? Trim<Prop> | ExtractVars<Rest>`);
  lines.push(`    : never;`);
  lines.push(``);
  lines.push(`  export function getText<K extends keyof typeof texts>(`);
  lines.push(`    id: K,`);
  lines.push(`    ...args: ExtractVars<(typeof texts)[K]> extends never`);
  lines.push(`      ? []`);
  lines.push(`      : [vars: { [P in ExtractVars<(typeof texts)[K]>]: string | number }]`);
  lines.push(`  ): string`);
  lines.push(`}`);
  lines.push(``);

  return lines.join('\n');
}

export function writeIfChanged(filePath: string, content: string): boolean {
  if (fs.existsSync(filePath)) {
    const old = fs.readFileSync(filePath, 'utf-8');
    if (old === content) return false;
  }

  // Ensure directory exists
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  fs.writeFileSync(filePath, content, 'utf-8');
  return true;
}
